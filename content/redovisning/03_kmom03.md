---
---
Redovisning kmom03
=========================

Tredje kursmomentet handlade mycket om enhetstestning men också en hel del objektorienterad kodning. Det var inte helt lätt att få allting på plats och att fungera och dessutom vara hyfsat organiserat. Det var en rolig utmaning. Jag har ingen tidigare erfarenhet av att skriva kod för testning så det var intressant att göra. Det kräver verkligen att man tänker på ett nytt sätt både när man skriver original-koden och när man skriver testkoden. testning är en viktig del både för att säkerställa koden man skrivit men också att ha med sig till dokumentationen. Helst skall det ju då också vara test som kan upprepas utav dem som tar emot koden. Enhetstestning känns på det hela taget som ett praktiskt sätt att testa koden, man testar små delar i taget och kan då lätt se vilka delar som inte fungerar som tänkt. det blir också tydliga testfall. Något jag upptäckte är att beroende på koden som skall testas är skriven så säger inte enhetstester alltid så mycket, vissa av testerna jag skrev gjorde att all min kod testades men jag kan känna att testerna kan behöva kompletteras för att säkerställa att vissa funktioner fungerar som tänkt.

Samtidigt som jag skriver koden så testar jag ju också funktionerna så att de fungerar som tänkt. Enhetstestning som är whiteboxing kompletteras på så sätt av funktionstester som brukar vara mer blackboxing. Om man är utvecklare som skall ge koden till en beställare som i sin tur har användare så behöver man räkna med att beställaren ofta vill testa den färdiga varan. Ofta är det också så att man vill hålla sin egna kod inkapslad för att andra inte skall komma åt den och göra ändringar som förstör funktionerna. Man bör därför räkna med att den som beställt koden kommer att utföra funktionstester utifrån deras användares perspektiv och bör själv göra det. De tester man utför medans man kodar kan nog till stor del anses vara greyboxing, man testar funktionen men har insyn i koden och använder det GUI som är tänkt att användas. Ofta testar man dock bara den lilla del man just kodat och gör sedan ändringar tills det fungerar som tänkt.

Uppgiften med tärningsspelet var som sagt inte helt enkel. Jag började med att utgå från de klasser jag redan gjort i tidigare uppgifter och som skapade tärningar händer av tärningar och kunde lägga till grafik. Jag lade till en klass för att hantera en runda i spelet. Till en början så hamnade mycket av koden i routern tills jag visste hur jag ville att spelet skulle fungera. Jag skapade också flera vyer för att inte låta GUIt vara intelligent utan bara visa information och ge möjlighet att skicka in information. När jag sedan hade en version som fungerade ungefär som jag ville började jag se på var jag upprepade mig själv och vad som kunde flyttas från router till klasser. Jag försökte göra koden mer DRY och la över en stor del av koden till funktioner. En stor del här var att få till att bara ha en vy som renderades oavsett vilken rout som valdes och låta de värden man gav vyn avgöra vilka val spelaren hade. Tillslut skapade jag en klass till för att bestämma hur datorn skulle agera. det är en klass som är tänkt att fyllas på när man vill göra datorn mer nyanserad och intelligent. Jag ville ha ett spel där mycket låg i klasser och det var tydligt vilka klasser som gjorde vad men där det också skulle vara enkelt att lägga in fler variabler som kunde påverka spelet och där det skulle finna utvecklingspotential. Jag ville också ha ett GUI där användaren bara kunde genomföra de val som var aktuella (t.ex. inte avsluta datorns runda i förtid).

Min TIL det här kursmomentet är nog att enhetsester med randomiserade värden inte är helt enkelt att göra speciellt inte när de randomiserade värdena påverkar resultatet från t.ex. en if-sats. Man kan ibland behöva lägga till variabler som inte behövs för funktionen men som behövs för att kunna testa funktionen. Eller för den delen lägga till funktioner som inte behövs till annat än att kunna testa övrig kod.
